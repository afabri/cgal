\section{Examples}
\label{AABB_tree_section_examples}

\subsection{Tree of Triangles, for Intersection and Distance Queries}
In the following example a set of 3D triangles is stored in a list. The AABB primitive wraps a triangle as \ccc{datum} and an iterator in the list as \ccc{id}. We compute the number of input triangles intersected by a ray query, as well as the closest point and the squared distance from a point query.  
\ccIncludeExampleCode{AABB_tree/AABB_triangle_3_example.cpp}

\subsection{Tree of Polyhedron Triangle Facets for Intersection Queries}
In the following example the AABB primitive wraps a facet handle of a triangle polyhedral surface as \ccc{id} and the corresponding 3D triangle as geometric object. From a segment query we test the intersections, then compute the number of intersections, compute the first encountered intersection (generally a point), compute all intersections (where each intersection is a pair of one \cgal\ object and one primitive id - here a face handle) and compute all intersected primitives. The latter involves only tests and no predicates and is hence faster than computing all intersections. We also compute the first encountered intersection with a plane query, which is generally a segment.
\ccIncludeExampleCode{AABB_tree/AABB_polyhedron_facet_intersection_example.cpp}

\subsection{Tree of Polyhedron Triangle Facets for Distance Queries}
In the following example the AABB primitive wraps a facet handle of a triangle polyhedral surface as \ccc{id} and the corresponding 3D triangle as geometric object. From a point query we compute the squared distance, the closest point as well as the closest point and primitive id. The latter returns a pair composed of a point and a face handle. 
\ccIncludeExampleCode{AABB_tree/AABB_polyhedron_facet_distance_example.cpp}

\subsection{Tree of Segments for Intersection and Distance Queries}
In the following example the segments are stored into a list, and the AABB primitive wraps a segment as \ccc{datum} and an iterator in the list as \ccc{id}. We compute the number of intersections with plane and triangles queries, and the closest point from a point query. 
\ccIncludeExampleCode{AABB_tree/AABB_segment_3_example.cpp}

\subsection{Tree of Polyhedron Edge Segments for Intersection and Distance Queries}
In the following example the AABB primitive wraps a halfedge handle as \ccc{id} and generates a 3D segment on the fly, each time its method \ccc{datum} is called. We compute the number of intersections with a triangle query and the closest point from a point query. 
\ccIncludeExampleCode{AABB_tree/AABB_polyhedron_edge_example.cpp}

\subsection{Incremental Insertion of Primitives}
The AABB tree is a static data structure, but it allows to insert primitives, and will internally
rebuild triggered by the first query, or because the user calls the \ccc{build} method.
The following example illustrates this for two polyhedral surfaces.

\ccIncludeExampleCode{AABB_tree/AABB_insertion_example.cpp}

\subsection{Trees of Custom Primitives}

The AABB tree example folder contains three examples of trees constructed with customize primitives. In \ccc{AABB_custom_example.cpp} the primitive contains triangles which are defined by three pointers to custom points. In \ccc{AABB_custom_triangle_soup_example.cpp} all input triangles are stored into a single array so as to form a triangle soup. The primitive internally uses a \ccc{boost::iterator_adaptor} so as to provide the three functions (\ccc{id()}, \ccc{datum()}, \ccc{reference_point()}) required by the primitive concept. In \ccc{AABB_custom_indexed_triangle_set_example.cpp} the input is an indexed triangle set stored through two arrays: one array of points and one array of indices which refer to the point array. Here also the primitive internally uses a \ccc{boost::iterator_adaptor}.

